#!/usr/bin/python

# inv_exec
# Created by Disa Mhembere on 2013-03-21.
# Email: dmhembe1@jhu.edu
# Copyright (c) 2013. All rights reserved.

# A python script to run invariants on a file based on CL flag

import argparse
import sys
import os

from computation.utils import loadAdjMatrix

from eigs_mad_deg_tri import eigs_mad_deg_tri
from vert_edge_deg_ss_cc import vert_edge_deg_ss_cc

import mrcap.lcc as lcc
import mrcap.svd as svd
from  mrcap.gengraph import genGraph
from computation.utils.getBaseName import getBaseName

from computation.utils.file_util import getPathLeaf, makeDirIfNone

# Some default constants that can be changed freely as necessary
# Data directories
'''
DEG_DIR = os.path.join(MR_DATA_DIR, "Degree")
EIGV_DIR = os.path.join(MR_DATA_DIR, "Eigen")
CC_DIR = os.path.join(MR_DATA_DIR, "ClustCoeff")
MAD_DIR = os.path.join(MR_DATA_DIR, "MAD")
SS1_DIR = os.path.join(MR_DATA_DIR, "ScanStat1")
TRI_DIR = os.path.join(MR_DATA_DIR, "Triangle")
SVD_DIR = os.path.join(MR_DATA_DIR, "SVD")

# File naming suffixes
SVD_FN_SFX = '_embed'
DEG_FN_SFX = '_degree'
VER_FN_SFX = '_vertnum' #TODO
EIGVL_FN_SFX = '_eigvl' # eigenvalue
EIGVC_FN_SFX = '_eigvec' # eigenvalue
MAD_FN_SFX = '_mad' # max ave degree
TRI_FN_SFX = '_triangles'
CLST_FN_SFX = '_clustcoeff'
EDGE_FN_SFX = '_numedges.npy'
'''

################################################################################
#                             COMPUTE INVARIANTS                               #
################################################################################
def compute_inv(inv_dict):
  '''
  @todo
  @param lccG: Sparse largest connected component adjacency matrix
  @param inv_dict: current session dict containing session varibles
  '''
  # Add filenames with None attached since invariant computations look
  # for filenames when asked to compute an invariant - if they see 'None'
  # they will compute it & populate the file name. If they see a file name,
  # they won't recompute it.

  inv_dict['deg_fn'] = inv_dict['eigvl_fn'] = inv_dict['eigvect_fn'] = inv_dict['tri_fn'] \
        = inv_dict['mad_fn'] = inv_dict['cc_fn'] = inv_dict['ver_fn'] = inv_dict['ss1_fn']\
        = inv_dict['edge_fn']  = None

  print "Computing invariants ..."

  if (inv_dict['ss1'] or inv['cc']):
    vert_edge_deg_ss_cc(inv_dict)
  if (inv_dict['eig'] or inv_dict['mad'] or inv_dict['tri']):
    eigs_mad_deg_tri(inv_dict)

  # pick one - doesnt matter
  vert_edge_deg_ss_cc(inv_dict)


def main():
  # Constants
  SM_GRAPH_FN_SFX = '_70_smgr' # 70 may change
  BG_GRAPH_FN_SFX = '_bggr'

  mr_data_dir = os.path.join(os.path.dirname(__file__), 'mrdata')

  parser = argparse.ArgumentParser(description='A script run selected/all invariants on the largest\
                                   connected component of a graph. Pass minimally only G_fn[-l]|-f -rx -rr')

  # If fiber_fn is passed the assumption is that you don't have a
  # graph & want it made under the default name or G_fn if provided

  # Files and storage
  parser.add_argument('graphsize', action='store', help='graphsize [s|b]. s is for small and b is for big.')
  parser.add_argument('graph_fn', action='store',help='the full filename of the  \
                      CSC matrix representing a graph (.mat format) to have *NOTE DO NOT USE UNDERSCORES (_)')
  parser.add_argument('-S', '--savedir', action='store', help='the directory where the invariants \
                      are to be stored (each invariant will create its own subdirectory within this). \
                      The defualt is %s' % mr_data_dir)

  parser.add_argument('-l', '--lcc', action='store_true',help='the full filename of the largest connected component (.npy format)')

  # Invariant options
  parser.add_argument('-A', '--all', action='store_true', help='pass to compute ALL invariants')
  parser.add_argument('-d', '--deg', action='store_true', help='pass to compute local degree of lcc')
  parser.add_argument('-e', '--eigs', action='store_true', help='pass to compute global top k eigenvalues & eigenvectors of lcc')
  parser.add_argument('-c', '--cc', action='store_true', help='pass to compute local clustering coefficient of lcc')
  parser.add_argument('-t', '--tri', action='store_true', help='pass to compute local triangle count of lcc')
  parser.add_argument('-s', '--ss1', action='store_true', help='pass to compute scan 1 statistic of lcc')
  parser.add_argument('-m', '--mad', action='store_true', help='pass to compute global max. average degree of lcc')
  parser.add_argument('-g', '--edge', action='store_true', help='pass to compute global egde count of lcc')
  parser.add_argument('-v', '--ver', action='store_true', help='pass to compute global vertex count of lcc')

  result = parser.parse_args()

  if (result.graphsize == 'b' and not result.lcc):
    sys.stderr.write("You must provide lcc given a biggraph \n")
    sys.exit(-1)

  if result.savedir:
    mr_data_dir = result.savedir

  if result.all:
    for key in result.__dict__:
      if result.__dict__[key] == False:
        result.__dict__[key] = True

  compute_inv(result.__dict__)

if __name__ == '__main__':
  main()